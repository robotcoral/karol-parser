/*
function compileWhile(str: string, cursor: TreeCursor): InnerCompilationResult {
	let pos: Position = {from: cursor.from, to: cursor.to};
	cursor.firstChild(); // "wiederhole"
	cursor.nextSibling();

	let condType: string = getVal(str, cursor);
	let inv: boolean = false;
	let times: number = 0;
	let cond:IdentifierCompilationResult = { kind: "success", result: { kind: "statement", identifier: "dummy", pos: pos}};
	if(condType === "solange") {
		cursor.nextSibling();
		if(getVal(str, cursor) === "nicht") {
			cursor.nextSibling();
			inv = true;
		}
		cond = compileIdentifier(str, cursor);
		if(cond.kind === "error")
			return cond;
	} else if(cursor.name === "Number") {
		times = Number(condType);
		cursor.nextSibling(); // mal
	}

	let body = [];
	while(cursor.nextSibling()) {
		let val = getVal(str, cursor);
		if(val === "endewiederhole" || val === "*wiederhole")
			break;
		
		let res = compileInner(str, cursor);
		if(res.kind === "error")
			return res;
		body.push(res.result);
	}

	cursor.parent();

	if(condType === "immer") {
		return { kind: "success", result: {kind: "whileForever", body: body, pos: pos} };
	} else if(condType === "solange") {
		return { kind: "success", result: {kind: "while", inverted: inv, condition: cond.result, body: body, pos: pos} };
	} else { // n mal
		return { kind: "success", result: {kind : "whileTimes", times: times, body: body, pos: pos}};
	}
}

function compileWhileEnd(str: string, cursor: TreeCursor): InnerCompilationResult {
	let pos: Position = {from: cursor.from, to: cursor.to};
	cursor.firstChild(); // "wiederhole"
	cursor.nextSibling();

	let body = [];
	while(cursor.nextSibling()) {
		let val = getVal(str, cursor);
		if(val === "endewiederhole" || val === "*wiederhole")
			break;
		
		let res = compileInner(str, cursor);
		if(res.kind === "error")
			return res;
		body.push(res.result);
	}

	cursor.nextSibling(); // "solange" | "bis"

	let condType: string = getVal(str, cursor);
	let inv: boolean = false;
	let bis: boolean = false;
	let cond:IdentifierCompilationResult;
	
	if(condType === "bis") {
		bis = true;
	}
	cursor.nextSibling();
	if(getVal(str, cursor) === "nicht") {
		cursor.nextSibling();
		inv = true;
	}
	cond = compileIdentifier(str, cursor);
	if(cond.kind === "error")
		return cond;

	cursor.parent();
	return { kind: "success", result: {kind: "whileEnd", inverted: inv !== bis, condition: cond.result, body: body, pos: pos} };
}

function compileIf(str: string, cursor: TreeCursor): InnerCompilationResult {
	let pos: Position = {from: cursor.from, to: cursor.to};
	cursor.firstChild(); // "wenn"
	cursor.nextSibling();
	
	let val: string = getVal(str, cursor);
	let inv: boolean = false;
	if(val === "nicht") {
		cursor.nextSibling();
		inv = true;
	}

	let cond:IdentifierCompilationResult = compileIdentifier(str, cursor);
	if(cond.kind === "error")
		return cond;
	
	cursor.nextSibling(); // "dann"

	let isElse: boolean = false;
	const body: TreeNode[] = [];
	const elseBody: TreeNode[] = [];

	while(cursor.nextSibling()) {
		val = getVal(str, cursor);
		if(val === "endewenn" || val === "*wenn")
			break;
		if(val === "sonst") {
			isElse = true;
			cursor.nextSibling();
		}

		if(isElse) {
			let res = compileInner(str, cursor);
			if(res.kind === "error")
				return res;
			elseBody.push(res.result);
		} else {
			let res = compileInner(str, cursor);
			if(res.kind === "error")
				return res;
			body.push(res.result);
		}
	}

	cursor.parent();
	if(isElse)
		return { kind: "success", result: {kind: "ifElse", inverted: inv, condition: cond.result, body: body, elseBody: elseBody, pos: pos}};
	
	return { kind: "success", result: {kind: "if", inverted: inv, condition: cond.result, body: body, pos: pos}};
}

function compileSubroutine(str: string, cursor: TreeCursor): SubroutineCompilationResult {
	let pos: Position = {from: cursor.from, to: cursor.to};
	cursor.firstChild(); // "Anweisung"
	cursor.nextSibling();
	let subName: string = getVal(str, cursor);
	
	let val;
	const body: TreeNode[] = [];
	while(cursor.nextSibling()) {
		val = getVal(str, cursor);
		if(val === "endeAnweisung" || val === "*Anweisung")
			break;
		
		let res = compileInner(str, cursor);
		if(res.kind === "error")
			return res;
		body.push(res.result);
	}
	cursor.parent();
	
	return { kind: "success", result: {kind: "subroutine", identifier: subName, body: body, pos: pos}};
}

function compileCondition(str: string, cursor: TreeCursor): ConditionCompilationResult {
	let pos: Position = {from: cursor.from, to: cursor.to};
	cursor.firstChild(); // "Bedingung"
	cursor.nextSibling();
	let subName: string = getVal(str, cursor);
	
	let val;
	const body: TreeNode[] = [];
	while(cursor.nextSibling()) {
		val = getVal(str, cursor);
		if(val === "endeBedingung" || val === "*Bedingung")
			break;
		
		let res = compileInner(str, cursor);
		if(res.kind === "error")
			return res;
		body.push(res.result);
	}
	cursor.parent();
	
	return { kind: "success", result: {kind: "condition", identifier: subName, body: body, pos: pos}};
}

function compileIdentifier(str: string, cursor: TreeCursor): IdentifierCompilationResult {
	let val: string = getVal(str, cursor);
	let pos: Position = {from: cursor.from, to: cursor.to};
	if(cursor.name === "IdentifierWithParam") {
		cursor.firstChild();
		val = getVal(str, cursor);
		cursor.nextSibling();
		cursor.nextSibling();
		let param: string = getVal(str, cursor);
		if(callIdentifiers.has(val) || conditionIdentifiers.has(val)) {
			cursor.parent();
			return { kind: "success", result: {kind: "statementWithParam", identifier: val, param: param, pos: pos}};
		} else {
			cursor.parent();
			return { kind: "error", msg: "subroutine/condition calls must not contain parameters", pos: pos };
		}
	} else {
		return { kind: "success", result: {kind: "statement", identifier: val, pos: pos}};
	}
}

function compileInner(str: string, cursor: TreeCursor): InnerCompilationResult {
	let val: string = getVal(str, cursor);
	let pos: Position = {from: cursor.from, to: cursor.to};
	switch(cursor.name) {
		case "Identifier":
			return compileIdentifier(str, cursor);
		case "IdentifierWithParam":
			return compileIdentifier(str, cursor);
		case "If":
			return compileIf(str, cursor);
		case "While":
			return compileWhile(str, cursor);
		case "WhileEnd":
			return compileWhileEnd(str, cursor);
		case "Subroutine":
			return { kind: "error", msg: "subroutine must not be declared inside another subroutine/condition declaration", pos: pos };
		case "Condition":
			return { kind: "error", msg: "condition must not be declared inside another subroutine/condition declaration", pos: pos };
		default: // faulty node detected -> parser error
			return { kind: "error", msg: "parse error", pos: pos };
	}
}


export function compile(str: string): CompilationResult {
	let cursor: TreeCursor = parse(str).cursor();
	const program: KarolProgram = {start: [], subroutines: {}, conditions: {}};
	
	cursor.firstChild();
	do {
		let val: string = getVal(str, cursor);
		let pos: Position = {from: cursor.from, to: cursor.to};
		let res: InnerCompilationResult;
		let subRes: SubroutineCompilationResult;
		let condRes: ConditionCompilationResult
		switch(cursor.name) {
			case "Subroutine":
				subRes = compileSubroutine(str, cursor);
				if(subRes.kind === "error")
					return subRes;
				if(program.subroutines[subRes.result.identifier] === undefined && program.conditions[subRes.result.identifier])
					program.subroutines[subRes.result.identifier] = subRes.result;
				else
					return { kind: "error", msg: "illegal subroutine redefintion", pos: pos };

				break;
			case "Condition":
				condRes = compileCondition(str, cursor);
				if(condRes.kind === "error")
					return condRes;
				if(program.conditions[condRes.result.identifier] === undefined && program.subroutines[condRes.result.identifier])
					program.conditions[condRes.result.identifier] = condRes.result;
				else
					return { kind: "error", msg: "illegal subroutine redefintion", pos: pos };

				break;
			default:
				res = compileInner(str, cursor);
				if(res.kind === "error")
					return res;
				program.start = program.start.concat(res.result);
				break;
		}
	} while (cursor.nextSibling());

	return { kind: "success", result: program };
}*/

	/*
export type Statement = { 
	kind: "statement"; 
	identifier: string; 
	pos: Position; 
}

export type StatementWithParam = { 
	kind: "statementWithParam"; 
	identifier: string; 
	param: string; 
	pos: Position; 
}

export type Subroutine = { 
	kind: "subroutine"; 
	identifier: string; 
	body: TreeNode[]; 
	pos: Position; 
}

export type Condition = {
	kind: "condition";
	identifier: string;
	body: TreeNode[];
	pos: Position;
}

export type If = {
	kind: "if";
	inverted: boolean;
	condition: Statement | StatementWithParam;
	body: TreeNode[];
	pos: Position;
}

export type IfElse = {
	kind: "ifElse";
	inverted: boolean;
	condition: Statement | StatementWithParam;
	body: TreeNode[];
	elseBody: TreeNode[];
	pos: Position;
}

export type WhileForever = {
	kind: "whileForever";
	body: TreeNode[];
	pos: Position;
}

export type WhileTimes = {
	kind: "whileTimes";
	times: number;
	body: TreeNode[];
	pos: Position;
}

export type While = {
	kind: "while";
	inverted: boolean;
	condition: Statement | StatementWithParam;
	body: TreeNode[];
	pos: Position;
}

export type WhileEnd = {
	kind: "whileEnd";
	inverted: boolean;
	condition: Statement | StatementWithParam;
	body: TreeNode[];
	pos: Position;
};

export type TreeNode = 
	| Statement 
	| StatementWithParam 
	| Subroutine 
	| Condition 
	| If 
	| IfElse 
	| WhileForever 
	| WhileTimes 
	| While 
	| WhileEnd; */